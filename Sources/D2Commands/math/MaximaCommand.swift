import SwiftDiscord
import D2Permissions
import D2Utils
import Dispatch

fileprivate let maxExecutionSeconds = 5

fileprivate let clearedInputChars = try! Regex(from: "\\|&,;")
fileprivate let maximaOutputPattern = try! Regex(from: "\\(%i1\\)\\s*([\\s\\S]+)\\(%i2\\)")

public class MaximaCommand: StringCommand {
	public let description = "Transforms and solves mathematical expressions using Maxima"
	public let sourceFile: String = #file
	public let requiredPermissionLevel = PermissionLevel.basic
	private let latexRenderer: LatexRenderer?
	private var running = false
	
	public init() {
		do {
			latexRenderer = try LatexRenderer()
		} catch {
			latexRenderer = nil
			print("Could not initialize latex renderer for MaximaCommand: \(error)")
		}
	}
	
	public func invoke(withStringInput input: String, output: CommandOutput, context: CommandContext) {
		guard !running else {
			output.append("Wait for the Maxima command to finish")
			return
		}
		
		let processedInput: String = clearedInputChars.replace(in: input, with: "")
		let maximaInput: String = (latexRenderer == nil) ? processedInput : "tex(\(processedInput))$"
		
		running = true
		let queue = DispatchQueue(label: "Maxima runner")
		let shell = Shell()
		let (pipe, process) = shell.newProcess("maxima", args: ["-q", "-r", maximaInput], withPipedOutput: true)
		
		let task = DispatchWorkItem {
			do {
				try shell.execute(process: process)
				process.waitUntilExit()
				
				guard let result = String(data: pipe!.fileHandleForReading.availableData, encoding: .utf8) else {
					output.append("No output was generated by Maxima")
					return
				}
				
				if let renderer = self.latexRenderer, let maximaOutput = maximaOutputPattern.firstGroups(in: result) {
					// Parse and render TeX output
					let tex = maximaOutput[1]
					// output.append("`\(tex)`")
					renderLatexPNG(with: renderer, from: tex, to: output) {
						self.running = false
					}
				} else {
					// Render text output directly instead
					output.append("```\n\(result)\n```")
					self.running = false
				}
			} catch {
				print("An error occurred in MaximaCommand: \(error)")
				self.running = false
			}
		}
		
		let timeout = DispatchTime.now() + .seconds(maxExecutionSeconds)
		queue.async(execute: task)
		
		DispatchQueue.global(qos: .userInitiated).async {
			_ = task.wait(timeout: timeout)
			print("Timed out")
			
			if process.isRunning {
				process.terminate()
			}
			
			self.running = false
		}
	}
}
